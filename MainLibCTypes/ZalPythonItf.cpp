/*
        Ctypes wrapper for Zal MainLib
        Exports some interfaces to be consumed by Python 3
*/

#define _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING
#define _SILENCE_CXX17_STRSTREAM_DEPRECATION_WARNING

#include <memory>
#include <cstring>
#include <iomanip>

#include "Logging.h"
#include "Singleton.h"
#include "Dictionary.h"
#include "Lexeme.h"
#include "WordForm.h"
#include "GramHasher.h"
#include "Parser.h"
#include "Analytics.h"
//#include "AspectPair.h"
#include "EString.h"
#include "Enums.h"

using namespace Hlib;

const int MAX_SIZE = 1000;

namespace MainLibForPython {

    auto pSingleton = Singleton::pGetInstance();
    shared_ptr<CDictionary> spDictionary;
    auto rc = pSingleton->eGetDictionary(spDictionary);

    struct StWordForm {

        long long llInflectionId;
        wchar_t szWordForm[MAX_SIZE] = { L'\0' };
        wchar_t szStem[MAX_SIZE] = { L'\0' };
        ET_PartOfSpeech ePos;
        ET_Case eCase;
        ET_Number eNumber;
        ET_Subparadigm eSubparadigm;
        ET_Gender eGender;
        ET_Person ePerson;
        ET_Animacy eAnimacy;
        ET_Reflexivity eReflexivity;
        ET_Aspect eAspect;
        ET_Status eStatus;
        bool bIrregular;      // came from the DB as opposed to being generated by the app
        wchar_t szLeadComment[MAX_SIZE] = { L'\0' };
        wchar_t szTrailingComment[MAX_SIZE] = { L'\0' };
        bool bIsEdited;
        bool bIsVariant;
//        wchar_t arrStress[MAX_SIZE] = { 0 };
        wchar_t szStress[MAX_SIZE] = { L'\0' };
        wchar_t szGrammHash[MAX_SIZE] = { L'\0' };
    };

#ifdef WIN32
    extern "C"
    {
        __declspec(dllexport) ET_ReturnCode GetDictionary(shared_ptr<CDictionary>&);
        __declspec(dllexport) bool Init(const wchar_t* szDbPath);
        __declspec(dllexport) bool bParseWord(const wchar_t* szWord);
        __declspec(dllexport) int iNumOfParses();
        __declspec(dllexport) bool GetParsedWordForm(int iNum, StWordForm* pstParsedForm);
        __declspec(dllexport) bool GenerateAllForms();
        __declspec(dllexport) void ReportProgress (int iPercentDone, bool bDone, int recordNumber, double dDuration);
        __declspec(dllexport) bool AddLexemeHashes();
        __declspec(dllexport) long long llParseText(const wchar_t* szTextName, const wchar_t* szMetadata, const wchar_t* szText, bool bIsProse);
    }
#else
    extern "C"
    {
        ET_ReturnCode GetDictionary(shared_ptr<CDictionary>&);
        bool Init(const wchar_t* szDbPath);
        bool bParseWord(const wchar_t* szWord);
        int iNumOfParses();
        bool GetParsedWordForm(int iNum, StWordForm* pstParsedForm);
        bool GenerateAllForms();
        void ReportProgress(int iPercentDone, bool bDone, int recordNumber, double dDuration);
        bool AddLexemeHashes();
        long long llParseText(const wchar_t* szTextName, const wchar_t* szMetadata, const wchar_t* szText, bool bIsProse);
    }
#endif

    static shared_ptr<CDictionary> g_spDictionary;
//    static shared_ptr<CParser> g_spParser;
//    static shared_ptr<CLexeme> g_spLexeme;
    static shared_ptr<CAnalytics> g_spAnalytics;

    static vector<shared_ptr<CWordForm>> vecWordForms;

    bool Init(const wchar_t* szDbPath)
    {
        auto pSingleton = Singleton::pGetInstance();

        ET_ReturnCode rc = pSingleton->eGetDictionary(g_spDictionary);

        if (rc != H_NO_ERROR || nullptr == g_spDictionary)
        {
            cout << L"Unable to intialize the dictionary." << endl;
            exit(-1);
        }

        rc = g_spDictionary->eSetDbPath(szDbPath);

        return true;
    }

    void CopyStressData(shared_ptr<CWordForm> spWf, wchar_t* szData) 
    {    
        try {

            int iPos = 0;
            ET_StressType eType = ET_StressType::STRESS_TYPE_UNDEFINED;
            CEString sReturn (L"Stress position(s): ");

            ET_ReturnCode eRet = spWf->eGetFirstStressPos(iPos, eType);
            do {

                if (eRet != H_NO_ERROR && eRet != H_FALSE)
                {
                    ERROR_LOG(L"Unable to read stress position.");
                    continue;
                }

                if (H_NO_ERROR == eRet)
                {
                    sReturn += CEString::sToString(iPos);
                    sReturn += L", type = ";
                    if (STRESS_PRIMARY == eType)
                    {
                        sReturn += L"primary";
                    }
                    else if (STRESS_SECONDARY == eType)
                    {
                        sReturn += L"secondary";
                    }
                    else
                    {
                        ERROR_LOG(L"Illegal stress type.");
                        continue;
                    }
                    eRet = spWf->eGetNextStressPos(iPos, eType);
                }

            } while (H_NO_ERROR == eRet);

            memcpy(szData, sReturn, sReturn.uiLength() * sizeof(wchar_t));


        }
        catch (...)
        {
            ERROR_LOG(L"Exception!");
            return;
        }
    
    }       //  CopyStressData(...)

    void FillWordFormData(shared_ptr<CWordForm> spSource, StWordForm * pTarget) {

        pTarget->llInflectionId = spSource->llInflectionId();
        std::memcpy(pTarget->szWordForm, spSource->sWordForm(), spSource->sWordForm().uiLength() * sizeof(wchar_t));
        std::memcpy(pTarget->szStem, spSource->sStem(), spSource->sStem().uiLength() * sizeof(wchar_t));
        pTarget->ePos = spSource->ePos();
        pTarget->eCase = spSource->eCase();
        pTarget->eNumber = spSource->eNumber();
        pTarget->eSubparadigm = spSource->eSubparadigm();
        pTarget->eGender = spSource->eGender();
        pTarget->ePerson = spSource->ePerson();
        pTarget->eAnimacy = spSource->eAnimacy();
        pTarget->eReflexivity = spSource->eReflexive();
        pTarget->eAspect = spSource->eAspect();
        pTarget->eStatus = spSource->eStatus();
        pTarget->bIrregular = spSource->bIrregular();      // came from the DB as opposed to being generated by the app
        memcpy(pTarget->szLeadComment, spSource->sLeadComment(), spSource->sLeadComment().uiLength() * sizeof(wchar_t));
        memcpy(pTarget->szTrailingComment, spSource->sTrailingComment(), spSource->sTrailingComment().uiLength() * sizeof(wchar_t));
        pTarget->bIsEdited = spSource->bIsEdited();
        pTarget->bIsVariant = spSource->bIsVariant();
        memcpy(pTarget->szGrammHash, spSource->sGramHash(), spSource->sGramHash().uiLength() * sizeof(wchar_t));
        CopyStressData(spSource, pTarget->szStress);

    }       //  FillWordFormData()

    bool bParseWord(const wchar_t* szWord)
    {
        if (nullptr == g_spDictionary)
        {
            ERROR_LOG(L"Dictionary is not available.");
            exit(-1);
        }

        shared_ptr<CParser> spParser;
        ET_ReturnCode eRet = g_spDictionary->eGetParser(spParser);
        if (eRet != H_NO_ERROR)
        {
            ERROR_LOG(L"Unable to get parser object, exiting.");
            exit(-1);
        }

        spParser->ClearResults();
        vecWordForms.clear();

        eRet = spParser->eParseWord(szWord);
        if (eRet != H_NO_ERROR && eRet != H_FALSE)
        {
            cout << "Unable to parse word " << szWord << endl;
            return false;
        }

        if (H_FALSE == eRet)
        {
            cout << "Word " << szWord << "not found." << endl;
            return false;
        }

        shared_ptr<CWordForm> spWf;
        eRet = spParser->eGetFirstWordForm(spWf);
        if (eRet != H_NO_ERROR || nullptr == spWf)
        {
            cout << "Word " << szWord << ": unable to get first word form data." << endl;
            return false;
        }

        vecWordForms.push_back(spWf);

        while (H_NO_ERROR == eRet)
        {
            eRet = spParser->eGetNextWordForm(spWf);
            if (H_NO_ERROR == eRet)
            {
                if (nullptr == spWf)
                {
                    cout << "Word " << szWord << ": unable to get next word form data." << endl;
                    return false;
                }
                vecWordForms.push_back(spWf);
            }
        }

        return true;

    }       //  bParseWord()

    int iNumOfParses() 
    {
        return (int)vecWordForms.size();
    }

    bool GetParsedWordForm(int iNum, StWordForm* pParsedForm)
    {
        if (iNum < 0 || iNum >= (int)vecWordForms.size())
        {
            ERROR_LOG(L"Illegal parse index.");
            return false;
        }

//        auto num = vecWordForms.size();
        auto spWf = vecWordForms[iNum];
        FillWordFormData(spWf, pParsedForm);

//        cout << pstParsedForm->szWordForm;

        return true;

    }

    bool GenerateAllForms()
    {
        if (nullptr == g_spDictionary)
        {
            ERROR_LOG(L"Dictionary object not initialized.");
            return false;
        }

        ET_ReturnCode eRet = g_spDictionary->eGenerateAllForms();
        if (eRet != H_NO_ERROR)
        {
            cout << "Failed to generate word forms." << endl;
            return false;
        }

        return true;
    }

/*
    void ReportProgress(int iPercentDone, bool bOperationComplete, int iRecord, double dDuration)
    {
        cout << "Record " << iRecord << ", " << dDuration << " seconds." << endl;
        if (bOperationComplete)
        {
            cout << endl << "Done!" << endl << endl;
        }
    }
*/

    void ReportProgress(int iPercentDone, bool bOperationComplete, int iRecord, double dDuration)
    {
        cout << "Record " << right << setw(7) << iRecord << ", " << fixed << setprecision(3) << dDuration << " seconds, " << setw(4) << iPercentDone << "%" << endl;
        if (bOperationComplete)
        {
            cout << endl << "****    Done!" << endl << endl;
        }
    }

    bool AddLexemeHashes()
    {
        if (nullptr == g_spDictionary)
        {
            ERROR_LOG(L"Dictionary is not available.");
            exit(-1);
        }

        cout << endl << "****      ADDING LEXEME HASHES" << endl << endl;
        ET_ReturnCode eRet = g_spDictionary->ePopulateHashToDescriptorTable(nullptr, &ReportProgress);
        if (eRet != H_NO_ERROR)
        {
            cout << "Failed to populate hash to descriptor table." << endl;
            return false;
        }

        return true;
    }


    //
    //  Analytics
    //

    long long llParseText(const wchar_t* szTextName, const wchar_t* szMetadata, const wchar_t* szText, bool bIsProse)
    {
        ET_ReturnCode eRet = H_NO_ERROR;

        if (nullptr == g_spDictionary)
        {
            ERROR_LOG(L"Dictionary is not available.");
            return - 1;
        }

        if (nullptr == g_spAnalytics)
        {
            eRet = g_spDictionary->eGetAnalytics(g_spAnalytics);
            if (eRet != H_NO_ERROR)
            {
                ERROR_LOG(L"Unable to get analytics object, exiting.");
                return -1;
            }
        }

        long long llParsedTextId = 0;
        eRet = g_spAnalytics->eParseText(szTextName, szMetadata, szText, llParsedTextId, bIsProse);
        if (H_NO_ERROR != eRet)
        {
            llParsedTextId = -1;
            wcout << endl << L"Failed to parse text " << szTextName << endl << endl;
        }

        return llParsedTextId;
    }


}       //  namespace MainLibForPython 
