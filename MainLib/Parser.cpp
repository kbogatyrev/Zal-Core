#define _SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING

#include <ctime>
#include <algorithm>

#include "SqliteWrapper.h"
#include "Endings.h"
#include "WordForm.h"
#include "Lexeme.h"
#include "Parser.h"
#include "ParsingTree.h"

using namespace Hlib;

CParser::CParser(shared_ptr<CDictionary> spDictionary) : m_spDictionary(spDictionary)
{}

CParser::~CParser()
{
    ClearResults();
}

ET_ReturnCode CParser::eParseWord(const CEString& sWord)
{
//    clock_t startTime = clock();

    m_vecWordForms.clear();

    if (!m_spDictionary)
    {
        return H_ERROR_DB;
    }

    if (nullptr == m_spEndingsTree)
    {
        m_spEndingsTree = make_shared<CParsingTree>(m_spDictionary->spGetDb());
    }

    ET_ReturnCode rc = H_NO_ERROR;

    rc = eIrregularFormLookup(sWord);
    if (rc != H_NO_ERROR)
    {
        ERROR_LOG(L"Irregular form lookup failed.");
    }

    auto bSpryazhSm = true;
    rc = eIrregularFormLookup(sWord, bSpryazhSm);
    if (rc != H_NO_ERROR)
    {
        ERROR_LOG(L"Irregular form lookup failed.");
    }

    rc = eWholeWordLookup(sWord);
    if (rc != H_NO_ERROR)
    {
        ERROR_LOG(L"Irregular form lookup failed.");
    }

    rc = eFormLookup(sWord);
    if (rc != H_NO_ERROR)
    {
        ERROR_LOG(L"Regular form lookup failed.");
    }

//    clock_t totalTime = clock() - startTime;

    eRemoveFalsePositives();

    for (auto& spWf : m_vecWordForms)
    {
        shared_ptr<CLexeme> spLexeme;
        m_spDictionary->eGetLexemeById(spWf->spLexeme()->llLexemeId(), spLexeme);
        if (nullptr == spLexeme)
        {
            CEString sMsg(L"Failed to get lexeme by ID, ID = ");
            sMsg += CEString::sToString(spWf->spLexeme()->llLexemeId());
            ERROR_LOG(sMsg);
            continue;
        }
        spWf->SetPos(spLexeme->ePartOfSpeech());
//        spWf->SetInflection(&&&&)
    }

    return m_vecWordForms.empty() ? H_FALSE : H_NO_ERROR;

}       // eParseWord()


// Remove regular forms mistakenly generated by the engine when
// an irregular form exists in the db, regular form with the same 
// gramm hash must be ignored
// TODO: variants!
ET_ReturnCode CParser::eRemoveFalsePositives()
{
    using pwfIterator = vector<shared_ptr<CWordForm>>::iterator;

    set<pwfIterator> setFalsePositives;
    for (auto& spMe : m_vecWordForms)
    {
        if (!spMe->bIrregular())
        {
            continue;
        }

        for (pwfIterator itOther = m_vecWordForms.begin(); itOther != m_vecWordForms.end(); ++itOther)
        {
            if (spMe->spLexeme()->llLexemeId() == (*itOther)->spLexeme()->llLexemeId())
            {
                if (spMe->sGramHash() == (*itOther)->sGramHash())
                {
                    if (!(*itOther)->bIrregular())
                    {
                        setFalsePositives.insert(itOther);
                        break;
                    }
                }
            }
        }
    }

    for (auto itFalsePositive : setFalsePositives)
    {
        m_vecWordForms.erase(itFalsePositive);
    }

    return H_NO_ERROR;

}       //  eRemoveFalsePositives()

//  Overloaded non-virtual versions for internal use
ET_ReturnCode CParser::eGetFirstWordForm(shared_ptr<CWordForm>& spWordForm)
{
    m_itCurrentWordForm = m_vecWordForms.begin();
    if (m_vecWordForms.end() == m_itCurrentWordForm)
    {
        return H_FALSE;
    }

    spWordForm = (*m_itCurrentWordForm);

    return H_NO_ERROR;
}

ET_ReturnCode CParser::eGetNextWordForm(shared_ptr<CWordForm>& spWordForm)
{
    if (m_itCurrentWordForm != m_vecWordForms.end())
    {
        ++m_itCurrentWordForm;
    }

    if (m_vecWordForms.end() == m_itCurrentWordForm)
    {
        return H_NO_MORE;
    }

    spWordForm = (*m_itCurrentWordForm);

    return H_NO_ERROR;
}

void CParser::ClearResults()
{
//    vector<unique_ptr<CWordForm>>::iterator itWf = m_vecWordForms.begin();
//    for (; itWf != m_vecWordForms.end(); ++itWf)
//    {
//        delete *itWf;
//    }
    m_vecWordForms.clear();
    m_spDictionary->Clear();
}

void CParser::SetDb(shared_ptr<CSqlite> spDb)
{
    m_spDb = spDb;
}


//
// Helpers
//

ET_ReturnCode CParser::eQueryDb(const CEString& sSelect, uint64_t& uiQueryHandle)
{
    ET_ReturnCode rc = H_NO_ERROR;

    if (nullptr == m_spDb)
    {
        assert(0);
        ERROR_LOG(L"DB pointer is NULL.");
        return H_ERROR_POINTER;
    }

    try
    {
        uiQueryHandle = m_spDb->uiPrepareForSelect(sSelect);
    }
    catch (CException& ex)
    {
        HandleDbException(ex);
        rc = H_ERROR_DB;
    }

    return rc;
}

ET_ReturnCode CParser::eIrregularFormLookup(const CEString& sWord, bool bSpryazhSm)
{
    CEString sIrregFormQuery(L"SELECT DISTINCT id, inflection_id, gram_hash, wordform, is_alternative FROM ");
    if (bSpryazhSm)
    {
        sIrregFormQuery += L"irregular_forms_spryazh_sm WHERE wordform = \"";
    }
    else
    {
        sIrregFormQuery += L"irregular_forms WHERE wordform = \"";
    }

    sIrregFormQuery += sWord;
    sIrregFormQuery += L'\"';

    try
    {
        uint64_t uiFormQueryHandle = m_spDb->uiPrepareForSelect(sIrregFormQuery);
        while (m_spDb->bGetRow(uiFormQueryHandle))
        {
            uint64_t llFormId = -1;
            m_spDb->GetData(0, llFormId, uiFormQueryHandle);

            uint64_t llInflectionId = -1;
            m_spDb->GetData(1, llInflectionId, uiFormQueryHandle);

            CEString sGramHash = -1;
            m_spDb->GetData(2, sGramHash, uiFormQueryHandle);

            CEString sWordForm;
            sWordForm.SetVowels(CEString::g_szRusVowels);
            m_spDb->GetData(3, sWordForm, uiFormQueryHandle);

            bool bIsAlternative = false;
            m_spDb->GetData(4, bIsAlternative, uiFormQueryHandle);       // what to do with this one?

            unique_ptr<CWordForm> pWf = make_unique<CWordForm>(sGramHash);
            pWf->SetIrregular(true);
            pWf->SetInflectionId(llInflectionId);
            pWf->SetIrregularFormId(llFormId);
            pWf->SetWordForm(sWordForm);

            CEString sIrregStressQuery(L"SELECT position, is_primary FROM ");
            if (bSpryazhSm)
            {
                sIrregStressQuery += L"irregular_stress_spryazh_sm WHERE form_id = \"";
            }
            else
            {
                sIrregStressQuery += L"irregular_stress WHERE form_id = \"";
            }
            sIrregStressQuery += CEString::sToString(llFormId);
            sIrregStressQuery += L'\"';
            uint64_t uiStressHandle = m_spDb->uiPrepareForSelect(sIrregStressQuery);
            while (m_spDb->bGetRow(uiStressHandle))
            {
                int iPosition = -1;
                m_spDb->GetData(0, iPosition, uiStressHandle);

                ET_StressType eType = STRESS_TYPE_UNDEFINED;
                int iType = (int)eType;
                m_spDb->GetData(1, iType, uiStressHandle);
                int iStressedSyll = sWordForm.uiGetSyllableFromVowelPos(iPosition);
                pWf->SetStressPos(iStressedSyll, (ET_StressType)iType);
            }
            m_spDb->Finalize(uiStressHandle);

            m_vecWordForms.push_back(move(pWf));
        }
        m_spDb->Finalize(uiFormQueryHandle);
    }
    catch (CException& ex)
    {
        CEString sMsg(L"Irregular form lookup error: ");
        sMsg += ex.szGetDescription();
        ERROR_LOG(sMsg);
        return H_EXCEPTION;
    }

    return H_NO_ERROR;

}       //  eIrregularFormLookup()

static CEString s_sWholeWordQuery(L"SELECT DISTINCT sd.gram_hash, sd.inflection_id, wf.id, wf.ending_data_id \
                                   FROM stems AS s INNER JOIN stem_data as sd \
                                   ON (sd.stem_id = s.id) INNER JOIN wordforms as wf \
                                   ON sd.id = wf.stem_data_id  \
                                   WHERE s.stem_string='#WORDFORM#'");

ET_ReturnCode CParser::eWholeWordLookup(const CEString& sWord)
{
    CEString sQuery(s_sWholeWordQuery);
    sQuery = sQuery.sReplace(L"#WORDFORM#", sWord);
    uint64_t uiFormQueryHandle = m_spDb->uiPrepareForSelect(sQuery);
    while (m_spDb->bGetRow(uiFormQueryHandle))
    {
        CEString sGramHash;
        m_spDb->GetData(0, sGramHash, uiFormQueryHandle);

        int64_t llInflectionId = -1;
        m_spDb->GetData(1, llInflectionId, uiFormQueryHandle);

        int64_t llFormId = -1;
        m_spDb->GetData(2, llFormId, uiFormQueryHandle);

        int64_t llEndingId = -1;
        m_spDb->GetData(3, llEndingId, uiFormQueryHandle);

        if (llEndingId < 0 || H_TRUE == m_spEndingsTree->eIsEmptyEnding(llEndingId))
        {
            unique_ptr<CWordForm> pWf = nullptr;
            try
            {
                pWf = make_unique<CWordForm>(sGramHash);
            }
            catch (CException& ex)
            {
                CEString sMsg (L"Zal exception, error code = ");
                sMsg += CEString::sToString(ex.iGetErrorCode());
                ERROR_LOG(sMsg);

                return H_ERROR_GENERAL;
            }
            catch (...)
            {
                CEString sMsg(L"Exception, error code = ");
                sMsg += CEString::sToString(m_spDb->iGetLastError());
                ERROR_LOG(sMsg);

                return H_ERROR_GENERAL;
            }

            pWf->SetIrregular(false);
            pWf->SetInflectionId(llInflectionId);
            pWf->SetDbKey(llFormId);
            pWf->SetWordForm(sWord);

            CEString sStressQuery(L"SELECT position, is_primary FROM stress_data WHERE form_id = \"");
            sStressQuery += CEString::sToString(llFormId);
            sStressQuery += L'\"';
            uint64_t uiStressHandle = m_spDb->uiPrepareForSelect(sStressQuery);
            while (m_spDb->bGetRow(uiStressHandle))
            {
                int iPosition = -1;
                m_spDb->GetData(0, iPosition, uiStressHandle);

                bool bIsPrimary = false;
                m_spDb->GetData(1, bIsPrimary, uiStressHandle);
                ET_StressType eType = bIsPrimary ? STRESS_PRIMARY : STRESS_SECONDARY;
                pWf->SetStressPos(iPosition, eType);
            }
            m_spDb->Finalize(uiStressHandle);

            m_vecWordForms.push_back(move(pWf));
        }
    }       //  while (m_spDb->bGetRow(...)) 
    m_spDb->Finalize(uiFormQueryHandle);

    return H_NO_ERROR;

}   //  eWholeWordLookup()

static CEString s_sWordFormQuery (L"SELECT DISTINCT wf.id, sd.gram_hash, sd.lexeme_id FROM stems AS s \
                                  INNER JOIN stem_data AS sd ON(s.id = sd.stem_id) \
                                  INNER JOIN wordforms AS wf ON(sd.id = wf.stem_data_id) \
                                  WHERE s.stem_string = '#STEM#' AND wf.ending_data_id \
                                  IN (SELECT ending_data.id FROM endings \
                                  INNER JOIN ending_data ON endings.id = ending_data.ending_id \
                                  WHERE endings.ending_string = '#ENDING#')");

ET_ReturnCode CParser::eFormLookup(const CEString& sWord)
{
    if (NULL == m_spEndingsTree)
    {
        return H_ERROR_POINTER;
    }

    m_spEndingsTree->eSplit(sWord);

    int iEndingLength = -1;
    ET_ReturnCode rc = m_spEndingsTree->eGetFirstMatch(iEndingLength);
    while (H_NO_ERROR == rc || H_FALSE == rc)
    {
        if (iEndingLength > 0)
        {
            try
            {
                CEString sStemCandidate = sWord.sSubstr(0, sWord.uiLength() - iEndingLength);
                CEString sEndingCandidate = sWord.sSubstr(sWord.uiLength() - iEndingLength);

                CEString sQuery(s_sWordFormQuery);
                sQuery = sQuery.sReplace(L"#STEM#", sStemCandidate);
                sQuery = sQuery.sReplace(L"#ENDING#", sEndingCandidate);

                uint64_t uiFormQueryHandle = m_spDb->uiPrepareForSelect(sQuery);

                while (m_spDb->bGetRow(uiFormQueryHandle))
                {
                    int64_t llFormId = -1;
                    m_spDb->GetData(0, llFormId, uiFormQueryHandle);

                    CEString sGramHash;
                    m_spDb->GetData(1, sGramHash, uiFormQueryHandle);

                    int64_t llInflectionId = -1;
                    m_spDb->GetData(2, llInflectionId, uiFormQueryHandle);

                    unique_ptr<CWordForm> pWf = make_unique<CWordForm>(sGramHash);
                    pWf->SetDbKey(llFormId);
                    pWf->SetIrregular(false);
                    pWf->SetInflectionId(llInflectionId);
                    pWf->SetWordForm(sWord);

                    CEString sStressQuery(L"SELECT position, is_primary FROM stress_data WHERE form_id = \"");
                    sStressQuery += CEString::sToString(llFormId);
                    sStressQuery += L'\"';

                    uint64_t uiStressHandle = m_spDb->uiPrepareForSelect(sStressQuery);
                    while (m_spDb->bGetRow(uiStressHandle))
                    {
                        int iPosition = -1;
                        m_spDb->GetData(0, iPosition, uiStressHandle);

                        bool bIsPrimary = false;
                        m_spDb->GetData(1, bIsPrimary, uiStressHandle);
                        pWf->SetStressPos(iPosition, bIsPrimary ? STRESS_PRIMARY : STRESS_SECONDARY);
                    }
                    m_spDb->Finalize(uiStressHandle);
                    m_vecWordForms.push_back(move(pWf));

                }       //  while (m_spDb->bGetRow(...))

                m_spDb->Finalize(uiFormQueryHandle);
            }
            catch (CException& ex)
            {
                CEString sMsg(L"Parse error: ");
                sMsg += ex.szGetDescription();
                ERROR_LOG(sMsg);
                return H_EXCEPTION;
            }
        }

        rc = m_spEndingsTree->eGetNextMatch(iEndingLength);

        if (H_FALSE == rc)
        {
            break;
        }

    }       //  while (H_NO_ERROR == rc)

    return H_NO_ERROR;

}       //  eFormLookup()

ET_ReturnCode eLexemeLookup([[maybe_unused]]const CLexeme& lexeme)
{
    return H_NO_ERROR;
}

void CParser::HandleDbException(CException& ex)
{
    CEString sMsg(ex.szGetDescription());
    CEString sError;
    try
    {
        m_spDb->GetLastError(sError);
        sMsg += CEString(L", error description: ");
        sMsg += sError;
    }
    catch (...)
    {
        sMsg = L"Apparent DB error ";
    }

    sMsg += L", error code = ";
    sMsg += CEString::sToString(m_spDb->iGetLastError());
    ERROR_LOG(sMsg);

}
